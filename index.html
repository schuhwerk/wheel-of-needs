<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Wheel of Needs / Bedürfnisrad</title>

    <!-- Social Media Sharing / Open Graph -->
    <meta property="og:title" content="Wheel of Needs / Bedürfnisrad">
    <meta property="og:description"
        content="Interactive, printable Wheel of Needs for non-violent communication. Features English/German support, multiple themes, and SVG export.">
    <meta property="og:image" content="docs/wheel-of-needs.png">
    <meta property="og:image:type" content="image/png">
    <meta property="og:type" content="website">
    <meta property="og:url" content=".">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Wheel of Needs / Bedürfnisrad">
    <meta name="twitter:description" content="Interactive, printable Wheel of Needs for non-violent communication.">
    <meta name="twitter:image" content="docs/wheel-of-needs.png">

    <!-- Compatibility Fallbacks -->
    <meta itemprop="name" content="Wheel of Needs / Bedürfnisrad">
    <meta itemprop="description" content="Interactive, printable Wheel of Needs for non-violent communication.">
    <meta itemprop="image" content="docs/wheel-of-needs.png">
    <link rel="image_src" href="docs/wheel-of-needs.png">

    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='50' fill='%23C2185B'/><path d='M50 50 L50 0 A50 50 0 0 1 100 50 Z' fill='%23F9A825'/><path d='M50 50 L100 50 A50 50 0 0 1 50 100 Z' fill='%23673AB7'/><path d='M50 50 L50 100 A50 50 0 0 1 0 50 Z' fill='%230277BD'/></svg>">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Global Layout */
            --bg-color: #f8fafc;
            --stroke-width: 3px;
            --border-color: #ffffff;

            /* Theme placeholder vars */
            --c-affiliation: #000;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        body {
            font-family: 'Lato', sans-serif;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            color: #334155;
            transition: background-color 0.3s;
        }

        /* --- Header UI --- */
        .ui-header {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 15px 10px 5px 10px;
            box-sizing: border-box;
            z-index: 20;
            flex-shrink: 0;
            background-color: transparent;
        }

        h1 {
            font-family: 'Lato', sans-serif;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 0 0 10px 0;
            font-size: clamp(20px, 5vw, 38px);
            font-weight: 900;
            text-align: center;
            line-height: 1.1;
            color: color-mix(in srgb, var(--c-affiliation), #475569 90%);
            transition: color 0.3s;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        select,
        button {
            padding: 8px 12px;
            height: 40px;
            box-sizing: border-box;
            font-family: 'Lato', sans-serif;
            font-size: 14px;
            font-weight: 700;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.9);
            color: #475569;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            outline: none;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        select:hover,
        button:hover {
            border-color: #94a3b8;
            background-color: white;
        }

        button {
            padding: 8px;
            width: 40px;
            background-color: #f1f5f9;
        }

        button:hover {
            background-color: #e2e8f0;
        }

        button svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* --- Viewport --- */
        #viewport {
            flex: 1;
            width: 100%;
            display: block;
            position: relative;
            overflow: hidden;
            cursor: grab;
            touch-action: none;
        }

        #viewport:active {
            cursor: grabbing;
        }

        #wheel-container {
            width: 900px;
            height: 900px;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
        }

        svg {
            width: 100%;
            height: 100%;
            overflow: visible;
            display: block;
        }

        .is-interacting .wheel-shadow-group {
            filter: none !important;
        }

        text {
            pointer-events: none;
            font-family: 'Lato', sans-serif;
            user-select: none;
        }

        .spoke-text {
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 0.3px;
        }

        .category-text {
            font-family: 'Lato', sans-serif;
            font-size: 22px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            fill: #1e293b;
        }

        path.segment {
            transition: opacity 0.2s ease;
            stroke-linejoin: round;
        }

        path.segment:hover {
            opacity: 0.85;
            cursor: pointer;
        }

        .attribution {
            position: fixed;
            bottom: 10px;
            right: 15px;
            font-size: 10px;
            color: #94a3b8;
            text-decoration: none;
            z-index: 100;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .attribution:hover {
            opacity: 1;
            text-decoration: underline;
        }

        /* --- PRINT STYLES --- */
        @media print {
            .attribution {
                display: none !important;
            }

            @page {
                margin: 0.5cm;
                size: auto;
            }

            body {
                padding: 0;
                padding-top: 0.5cm;
                background-color: white !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                overflow: hidden;
                display: block;
                height: 100vh;
            }

            .ui-header {
                padding: 0;
                margin-bottom: 0.5cm;
            }

            .controls {
                display: none !important;
            }

            h1 {
                margin: 0;
                font-size: 20px;
                color: #1e293b !important;
            }

            #viewport {
                display: block;
                width: 100%;
                height: auto;
                overflow: visible;
            }

            #wheel-container {
                position: relative;
                width: 100%;
                max-width: 18cm;
                /* limit width to fit A4 */
                height: auto;
                margin: 0 auto;
                transform: none !important;
                top: auto;
                left: auto;
            }

            /* FIX: Ensure shadow is kept during print */
            .wheel-shadow-group {
                filter: url(#wheelShadow) !important;
                -webkit-print-color-adjust: exact;
            }
        }
    </style>
</head>

<body class="theme-wrapper">

    <div class="ui-header">
        <h1 id="title">Wheel of Needs</h1>
        <div class="controls">
            <select id="theme-selector">
                <option value="humanist" selected>Theme: Vibrant Humanist</option>
                <option value="pastel">Theme: Pastel Soft</option>
                <option value="retro">Theme: Retro Pop</option>
                <option value="sunset">Theme: Sunset Geometry</option>
            </select>
            <select id="lang-selector">
                <option value="en" selected>English</option>
                <option value="de">Deutsch</option>
            </select>

            <button id="btn-print" title="Print" aria-label="Print">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z" />
                </svg>
            </button>

            <button id="btn-download" title="Download SVG" aria-label="Download SVG">
                <svg viewBox="0 0 24 24">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" />
                </svg>
            </button>
        </div>
    </div>

    <div id="viewport">
        <div id="wheel-container"></div>
    </div>

    <script>
        // --- Configuration ---
        const size = 900;
        const cx = size / 2;
        const cy = size / 2;

        const r_center_hole = 45;
        const r_inner = 160;
        const r_middle = 260;
        const r_outer = 410;
        const strokeWidth = 3;

        const palettes = {
            humanist: { affiliation: '#C2185B', selfDet: '#F9A825', rest: '#673AB7', safety: '#0277BD', bg: '#ffffff' },
            pastel: { affiliation: '#e37c77', selfDet: '#f1b552', rest: '#8e95d9', safety: '#73b7e0', bg: '#ffffff' },
            retro: { affiliation: '#E76F51', selfDet: '#E9C46A', rest: '#264653', safety: '#2A9D8F', bg: '#fdfbf7' },
            sunset: { affiliation: '#FF0055', selfDet: '#FF9A00', rest: '#6A0572', safety: '#00BFA5', bg: '#fff0f5' }
        };

        const i18n = {
            en: {
                title: "Wheel of Needs",
                outer: {
                    affiliation: ["Intimacy", "Community", "Respect", "Acceptance", "Understanding", "Closeness", "Honesty", "Contact"],
                    selfDet: ["Autonomy", "Voluntariness", "Individuality", "Privacy", "Freedom", "Independence", "Authenticity", "Self-reliance"],
                    rest: ["Harmony", "Recovery", "Peace", "Serenity", "Silence", "Comfort", "Retreat", "Coziness"],
                    safety: ["Shelter", "Honesty", "Trust", "Clarity", "Orientation", "Commitment", "Stability", "Mindfulness"]
                },
                inner: [
                    { text: "Appreciation" }, { text: "Exchange" }, { text: "Contribution" }, { text: "Growth" },
                    { text: "Efficacy" }, { text: "Variety" }, { text: "Beauty" }, { text: "Ease" },
                    { text: "Balance" }, { text: "Justice" }, { text: "Support" }, { text: "Inclusion" }
                ],
                middle: [{ text: "Belonging" }, { text: "Self-Determination" }, { text: "Rest" }, { text: "Safety" }]
            },
            de: {
                title: "Bedürfnisrad",
                outer: {
                    affiliation: ["Intimität", "Gemeinschaft", "Respekt", "Akzeptanz", "Verständnis", "Nähe", "Aufrichtigkeit", "Kontakt"],
                    selfDet: ["Autonomie", "Freiwilligkeit", "Individualität", "Privatsphäre", "Freiheit", "Unabhängigkeit", "Authentizität", "Eigenständigkeit"],
                    rest: ["Harmonie", "Erholung", "Frieden", "Gelassenheit", "Stille", "Bequemlichkeit", "Rückzug", "Gemütlichkeit"],
                    safety: ["Geborgenheit", "Ehrlichkeit", "Vertrauen", "Klarheit", "Orientierung", "Verbindlichkeit", "Beständigkeit", "Achtsamkeit"]
                },
                inner: [
                    { text: "Wertschätzung" }, { text: "Austausch" }, { text: "Beitragen" }, { text: "Entwicklung" },
                    { text: "Wirksam sein" }, { text: "Abwechslung" }, { text: "Schönheit" }, { text: "Leichtigkeit" },
                    { text: "Balance" }, { text: "Gerechtigkeit" }, { text: "Unterstützung" }, { text: "Dazugehören" }
                ],
                middle: [{ text: "Zugehörigkeit" }, { text: "Selbstbestimmung" }, { text: "Entspannung" }, { text: "Sicherheit" }]
            }
        };

        function mixWhite(hex, amount) {
            let c = hex.replace('#', '');
            if (c.length === 3) c = c.split('').map(x => x + x).join('');
            const r = parseInt(c.substring(0, 2), 16);
            const g = parseInt(c.substring(2, 4), 16);
            const b = parseInt(c.substring(4, 6), 16);
            const mix = (start, end, t) => Math.round(start * (1 - t) + end * t);
            return `rgb(${mix(r, 255, amount)}, ${mix(g, 255, amount)}, ${mix(b, 255, amount)})`;
        }

        function getContrastColor(hexColor, isOuter) {
            if (isOuter) return '#1e293b';
            const hex = hexColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return (yiq >= 128) ? '#1f2937' : '#ffffff';
        }

        function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
            var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
            return { x: centerX + (radius * Math.cos(angleInRadians)), y: centerY + (radius * Math.sin(angleInRadians)) };
        }

        function createSectorPath(x, y, rInner, rOuter, startAngle, endAngle) {
            let start = startAngle;
            let end = endAngle;
            if (end < start) end += 360;
            const startOuter = polarToCartesian(x, y, rOuter, end);
            const endOuter = polarToCartesian(x, y, rOuter, start);
            const startInner = polarToCartesian(x, y, rInner, end);
            const endInner = polarToCartesian(x, y, rInner, start);
            const largeArcFlag = end - start <= 180 ? "0" : "1";
            return `M ${startOuter.x} ${startOuter.y} A ${rOuter} ${rOuter} 0 ${largeArcFlag} 0 ${endOuter.x} ${endOuter.y} L ${endInner.x} ${endInner.y} A ${rInner} ${rInner} 0 ${largeArcFlag} 1 ${startInner.x} ${startInner.y} Z`;
        }

        function getTangentialRotation(angle, x, y) {
            let rotation = angle + 90;
            let normalizedRot = (rotation % 360 + 360) % 360;
            if (normalizedRot > 90 && normalizedRot < 270) rotation += 180;
            return `rotate(${rotation}, ${x}, ${y})`;
        }

                function getQueryParam(param) {
                    const urlParams = new URLSearchParams(window.location.search);
                    return urlParams.get(param);
                }
        
                function setQueryParam(param, value) {
                    const urlParams = new URLSearchParams(window.location.search);
                    urlParams.set(param, value);
                    const newUrl = window.location.pathname + '?' + urlParams.toString();
                    window.history.replaceState(null, '', newUrl);
                }
        
                let currentLang = getQueryParam('lang') || 'en';
                let currentTheme = getQueryParam('theme') || 'humanist'; 
        
                // Validate params
                if (!i18n[currentLang]) currentLang = 'en';
                if (!palettes[currentTheme]) currentTheme = 'humanist';
        
                // Update selectors to match state
                document.getElementById('lang-selector').value = currentLang;
                document.getElementById('theme-selector').value = currentTheme;
        
                function renderWheel() {            const container = document.getElementById('wheel-container');
            container.innerHTML = '';
            const data = i18n[currentLang];
            const colors = palettes[currentTheme];
            document.getElementById('title').textContent = data.title;
            const root = document.querySelector(':root');
            root.style.setProperty('--bg-color', colors.bg);
            root.style.setProperty('--c-affiliation', colors.affiliation);
            const themeColors = {
                affiliation: { inner: colors.affiliation, middle: mixWhite(colors.affiliation, 0.3), outer: mixWhite(colors.affiliation, 0.6) },
                selfDet: { inner: colors.selfDet, middle: mixWhite(colors.selfDet, 0.3), outer: mixWhite(colors.selfDet, 0.6) },
                rest: { inner: colors.rest, middle: mixWhite(colors.rest, 0.3), outer: mixWhite(colors.rest, 0.6) },
                safety: { inner: colors.safety, middle: mixWhite(colors.safety, 0.3), outer: mixWhite(colors.safety, 0.6) }
            };

            const svgns = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgns, "svg");
            svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
            svg.setAttribute("xmlns", svgns);

            const defs = document.createElementNS(svgns, "defs");
            const filter = document.createElementNS(svgns, "filter");
            filter.setAttribute("id", "wheelShadow");
            filter.setAttribute("x", "-20%");
            filter.setAttribute("y", "-20%");
            filter.setAttribute("width", "140%");
            filter.setAttribute("height", "140%");
            const feDrop = document.createElementNS(svgns, "feDropShadow");
            feDrop.setAttribute("dx", "0");
            feDrop.setAttribute("dy", "10");
            feDrop.setAttribute("stdDeviation", "15");
            feDrop.setAttribute("flood-opacity", "0.15");
            filter.appendChild(feDrop);
            defs.appendChild(filter);
            svg.appendChild(defs);

            const mainGroup = document.createElementNS(svgns, "g");
            mainGroup.setAttribute("filter", "url(#wheelShadow)");
            mainGroup.setAttribute("class", "wheel-shadow-group");
            svg.appendChild(mainGroup);

            const outerSectors = [
                { key: 'affiliation', color: themeColors.affiliation.outer, start: 225 },
                { key: 'selfDet', color: themeColors.selfDet.outer, start: 315 },
                { key: 'rest', color: themeColors.rest.outer, start: 45 },
                { key: 'safety', color: themeColors.safety.outer, start: 135 }
            ];
            const middleSectors = [
                { key: 'affiliation', text: data.middle[0].text, color: themeColors.affiliation.middle, start: 225, end: 315, reversed: false },
                { key: 'selfDet', text: data.middle[1].text, color: themeColors.selfDet.middle, start: 315, end: 45, reversed: false },
                { key: 'rest', text: data.middle[2].text, color: themeColors.rest.middle, start: 45, end: 135, reversed: true },
                { key: 'safety', text: data.middle[3].text, color: themeColors.safety.middle, start: 135, end: 225, reversed: true }
            ];
            const catKeys = ['affiliation', 'selfDet', 'rest', 'safety'];
            const innerSegments = data.inner.map((item, i) => {
                const catIdx = Math.floor(i / 3);
                const subIdx = i % 3;
                const currentKey = catKeys[catIdx];
                const nextKey = catKeys[(catIdx + 1) % 4];
                const startAngle = 225 + (i * 30) + 15;
                const endAngle = startAngle + 30;

                if (subIdx < 2) {
                    return { text: item.text, type: 'solid', color: themeColors[currentKey].inner, baseCol: colors[currentKey], start: startAngle, end: endAngle };
                } else {
                    return { text: item.text, type: 'gradient', startColor: themeColors[currentKey].inner, endColor: themeColors[nextKey].inner, start: startAngle, end: endAngle };
                }
            });

            const outerCircle = document.createElementNS(svgns, "circle");
            outerCircle.setAttribute("cx", cx);
            outerCircle.setAttribute("cy", cy);
            outerCircle.setAttribute("r", r_outer);
            outerCircle.setAttribute("fill", "#fff");
            outerCircle.setAttribute("stroke", "var(--border-color)");
            outerCircle.setAttribute("stroke-width", strokeWidth * 6);
            outerCircle.setAttribute("class", "outer-rim");
            mainGroup.appendChild(outerCircle);

            const anglePerOuter = 360 / 32;
            outerSectors.forEach(sector => {
                let currentAngle = sector.start;
                data.outer[sector.key].forEach(text => {
                    const endAngle = currentAngle + anglePerOuter;
                    const midAngle = currentAngle + (anglePerOuter / 2);
                    const path = document.createElementNS(svgns, "path");
                    path.setAttribute("d", createSectorPath(cx, cy, r_middle, r_outer, currentAngle, endAngle));
                    path.setAttribute("fill", sector.color);
                    path.setAttribute("stroke", "var(--border-color)");
                    path.setAttribute("stroke-width", strokeWidth);
                    path.setAttribute("class", "segment");
                    mainGroup.appendChild(path);
                    const textEl = document.createElementNS(svgns, "text");
                    const textRadius = (r_middle + r_outer) / 2;
                    const pos = polarToCartesian(cx, cy, textRadius, midAngle);
                    textEl.setAttribute("x", pos.x); textEl.setAttribute("y", pos.y);
                    textEl.setAttribute("fill", "#1e293b"); textEl.setAttribute("text-anchor", "middle"); textEl.setAttribute("dominant-baseline", "middle");
                    textEl.setAttribute("class", "spoke-text"); textEl.setAttribute("transform", getTangentialRotation(midAngle, pos.x, pos.y));
                    textEl.textContent = text; mainGroup.appendChild(textEl);
                    currentAngle = endAngle;
                });
            });

            middleSectors.forEach(item => {
                const path = document.createElementNS(svgns, "path");
                path.setAttribute("d", createSectorPath(cx, cy, r_inner, r_middle, item.start, item.end));
                path.setAttribute("fill", item.color); path.setAttribute("stroke", "var(--border-color)"); path.setAttribute("stroke-width", strokeWidth);
                path.setAttribute("class", "segment"); mainGroup.appendChild(path);
                const textPathId = `text-path-${item.key}`;
                const curvePath = document.createElementNS(svgns, "path");
                const tRadius = (r_inner + r_middle) / 2;
                let startA = item.start, endA = item.end; if (endA < startA) endA += 360;
                let p1, p2, sweep;
                if (item.reversed) { p1 = polarToCartesian(cx, cy, tRadius, endA); p2 = polarToCartesian(cx, cy, tRadius, startA); sweep = 0; }
                else { p1 = polarToCartesian(cx, cy, tRadius, startA); p2 = polarToCartesian(cx, cy, tRadius, endA); sweep = 1; }
                curvePath.setAttribute("d", `M ${p1.x} ${p1.y} A ${tRadius} ${tRadius} 0 0 ${sweep} ${p2.x} ${p2.y}`);
                curvePath.setAttribute("id", textPathId); curvePath.setAttribute("fill", "none"); defs.appendChild(curvePath);
                const textEl = document.createElementNS(svgns, "text");
                textEl.setAttribute("class", "category-text"); textEl.setAttribute("fill", "#1e293b"); textEl.setAttribute("dy", "9");
                const tp = document.createElementNS(svgns, "textPath");
                tp.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", `#${textPathId}`);
                tp.setAttribute("startOffset", "50%"); tp.setAttribute("text-anchor", "middle"); tp.textContent = item.text;
                textEl.appendChild(tp); mainGroup.appendChild(textEl);
            });

            innerSegments.forEach((item, index) => {
                let fillStyle = `fill: ${item.color}`;
                let midAngle = (item.start + item.end) / 2; if (item.end < item.start) midAngle = (item.start + item.end + 360) / 2;
                if (item.type === 'gradient') {
                    const gradId = `grad-${index}`; const gradRadius = (r_center_hole + r_inner) / 2;
                    let startA = item.start, endA = item.end; if (endA < startA) endA += 360;
                    const pStart = polarToCartesian(cx, cy, gradRadius, startA); const pEnd = polarToCartesian(cx, cy, gradRadius, endA);
                    const grad = document.createElementNS(svgns, "linearGradient");
                    grad.setAttribute("id", gradId); grad.setAttribute("gradientUnits", "userSpaceOnUse");
                    grad.setAttribute("x1", pStart.x); grad.setAttribute("y1", pStart.y); grad.setAttribute("x2", pEnd.x); grad.setAttribute("y2", pEnd.y);
                    const stop1 = document.createElementNS(svgns, "stop"); stop1.setAttribute("offset", "0%"); stop1.setAttribute("style", `stop-color: ${item.startColor}; stop-opacity: 1`);
                    const stop2 = document.createElementNS(svgns, "stop"); stop2.setAttribute("offset", "100%"); stop2.setAttribute("style", `stop-color: ${item.endColor}; stop-opacity: 1`);
                    grad.appendChild(stop1); grad.appendChild(stop2); defs.appendChild(grad);
                    fillStyle = `fill: url(#${gradId})`;
                }
                const path = document.createElementNS(svgns, "path");
                path.setAttribute("d", createSectorPath(cx, cy, r_center_hole, r_inner, item.start, item.end));
                path.setAttribute("style", fillStyle); path.setAttribute("stroke", "var(--border-color)"); path.setAttribute("stroke-width", strokeWidth);
                path.setAttribute("class", "segment"); mainGroup.appendChild(path);
                const textEl = document.createElementNS(svgns, "text");
                const textRadius = (r_center_hole + r_inner) / 2; const pos = polarToCartesian(cx, cy, textRadius, midAngle);
                textEl.setAttribute("x", pos.x); textEl.setAttribute("y", pos.y); textEl.setAttribute("text-anchor", "middle"); textEl.setAttribute("dominant-baseline", "middle");
                textEl.setAttribute("class", "spoke-text");
                let textColor = '#fff'; if (item.type === 'solid') textColor = getContrastColor(item.baseCol, false);
                textEl.setAttribute("fill", textColor); textEl.setAttribute("transform", getTangentialRotation(midAngle, pos.x, pos.y));
                textEl.textContent = item.text; mainGroup.appendChild(textEl);
            });
            container.appendChild(svg);
        }

        let scale = 1, pointX = 0, pointY = 0, isDragging = false, startX = 0, startY = 0, rafId = null;
        const viewport = document.getElementById('viewport');
        const el = document.getElementById('wheel-container');

        function updateTransform() {
            if (rafId) return;
            rafId = requestAnimationFrame(() => { el.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`; rafId = null; });
        }

        let interactionTimeout;
        function startInteraction() { clearTimeout(interactionTimeout); document.body.classList.add('is-interacting'); }
        function endInteraction() { clearTimeout(interactionTimeout); interactionTimeout = setTimeout(() => { document.body.classList.remove('is-interacting'); }, 100); }

        function initZoomPan() {
            viewport.addEventListener('wheel', (e) => {
                e.preventDefault(); startInteraction();
                const delta = -e.deltaY; const factor = delta > 0 ? 1.05 : 0.95;
                let newScale = scale * factor; if (newScale < 0.2) newScale = 0.2; if (newScale > 10) newScale = 10;
                const rect = viewport.getBoundingClientRect(); const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
                pointX = mouseX - (mouseX - pointX) * (newScale / scale); pointY = mouseY - (mouseY - pointY) * (newScale / scale);
                scale = newScale; updateTransform(); endInteraction();
            }, { passive: false });
            viewport.addEventListener('mousedown', (e) => { isDragging = true; startX = e.clientX - pointX; startY = e.clientY - pointY; viewport.style.cursor = 'grabbing'; startInteraction(); });
            window.addEventListener('mousemove', (e) => { if (!isDragging) return; e.preventDefault(); pointX = e.clientX - startX; pointY = e.clientY - startY; updateTransform(); });
            window.addEventListener('mouseup', () => { if (isDragging) { isDragging = false; viewport.style.cursor = 'grab'; endInteraction(); } });
            let lastDist = 0;
            viewport.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) { isDragging = true; startX = e.touches[0].clientX - pointX; startY = e.touches[0].clientY - pointY; startInteraction(); }
                else if (e.touches.length === 2) { isDragging = false; lastDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); startInteraction(); }
            }, { passive: false });
            viewport.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isDragging) { pointX = e.touches[0].clientX - startX; pointY = e.touches[0].clientY - startY; updateTransform(); }
                else if (e.touches.length === 2) {
                    e.preventDefault(); const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    if (lastDist) {
                        const newScale = scale * (dist / lastDist); const rect = viewport.getBoundingClientRect();
                        const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left; const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
                        pointX = midX - (midX - pointX) * (newScale / scale); pointY = midY - (midY - pointY) * (newScale / scale);
                        scale = newScale; updateTransform();
                    }
                    lastDist = dist;
                }
            }, { passive: false });
            viewport.addEventListener('touchend', () => { isDragging = false; lastDist = 0; endInteraction(); });
        }

        function centerWheel() {
            const vW = viewport.clientWidth; const vH = viewport.clientHeight;
            if (!vW || !vH) { setTimeout(centerWheel, 100); return; }
            const padding = 40; const targetScale = Math.min((vW - padding) / 900, (vH - padding) / 900);
            scale = targetScale > 1 ? 1 : targetScale; pointX = (vW - (900 * scale)) / 2; pointY = (vH - (900 * scale)) / 2;
            updateTransform();
        }

        function downloadSVG() {
            // FIX: Clone the SVG and inject hardcoded styles so strokes work in the saved file
            const svgEl = document.querySelector('#wheel-container svg').cloneNode(true);
            const style = document.createElementNS("http://www.w3.org/2000/svg", "style");
            style.textContent = `
                .segment, .outer-rim { stroke: #ffffff !important; }
                .spoke-text { font-family: 'Lato', sans-serif; font-weight: 700; font-size: 13px; letter-spacing: 0.3px; }
                .category-text { font-family: 'Lato', sans-serif; font-weight: 900; font-size: 22px; text-transform: uppercase; letter-spacing: 3px; }
            `;
            svgEl.prepend(style);

            const serializer = new XMLSerializer();
            let source = serializer.serializeToString(svgEl);
            if (!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) { source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"'); }
            if (!source.match(/^<svg[^>]+xmlns:xlink/)) { source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"'); }
            source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
            const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
            const downloadLink = document.createElement("a");
            downloadLink.href = url; downloadLink.download = "wheel-of-needs.svg";
            document.body.appendChild(downloadLink); downloadLink.click(); document.body.removeChild(downloadLink);
        }

        document.getElementById('btn-download').addEventListener('click', downloadSVG);
        document.getElementById('btn-print').addEventListener('click', () => window.print());

        document.getElementById('lang-selector').addEventListener('change', (e) => { 
            currentLang = e.target.value; 
            setQueryParam('lang', currentLang);
            renderWheel(); 
        });
        document.getElementById('theme-selector').addEventListener('change', (e) => { 
            currentTheme = e.target.value; 
            setQueryParam('theme', currentTheme);
            renderWheel(); 
        });

        renderWheel();
        initZoomPan();
        requestAnimationFrame(() => requestAnimationFrame(centerWheel));
        window.addEventListener('resize', centerWheel);
    </script>
    <a href="https://vs.digital" target="_blank" class="attribution">created by vs.digital</a>
</body>

</html>